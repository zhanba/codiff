export function equals<T>(
  one: ReadonlyArray<T> | undefined,
  other: ReadonlyArray<T> | undefined,
  itemEquals: (a: T, b: T) => boolean = (a, b) => a === b,
): boolean {
  if (one === other) {
    return true;
  }

  if (!one || !other) {
    return false;
  }

  if (one.length !== other.length) {
    return false;
  }

  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }

  return true;
}

export function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {
  for (const item of items) {
    arr.push(item);
  }
}

export function forEachAdjacent<T>(
  arr: T[],
  f: (item1: T | undefined, item2: T | undefined) => void,
): void {
  for (let i = 0; i <= arr.length; i++) {
    f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);
  }
}

/**
 * When comparing two values,
 * a negative number indicates that the first value is less than the second,
 * a positive number indicates that the first value is greater than the second,
 * and zero indicates that neither is the case.
 */
export type CompareResult = number;

/**
 * A comparator `c` defines a total order `<=` on `T` as following:
 * `c(a, b) <= 0` iff `a` <= `b`.
 * We also have `c(a, b) == 0` iff `c(b, a) == 0`.
 */
export type Comparator<T> = (a: T, b: T) => CompareResult;

export function compareBy<TItem, TCompareBy>(
  selector: (item: TItem) => TCompareBy,
  comparator: Comparator<TCompareBy>,
): Comparator<TItem> {
  return (a, b) => comparator(selector(a), selector(b));
}

/**
 * The natural order on numbers.
 */
export const numberComparator: Comparator<number> = (a, b) => a - b;

export function reverseOrder<TItem>(
  comparator: Comparator<TItem>,
): Comparator<TItem> {
  return (a, b) => -comparator(a, b);
}

export function forEachWithNeighbors<T>(
  arr: T[],
  f: (before: T | undefined, element: T, after: T | undefined) => void,
): void {
  for (let i = 0; i < arr.length; i++) {
    f(
      i === 0 ? undefined : arr[i - 1],
      arr[i],
      i + 1 === arr.length ? undefined : arr[i + 1],
    );
  }
}

/**
 * Splits the given items into a list of (non-empty) groups.
 * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.
 * The order of the items is preserved.
 */
export function* groupAdjacentBy<T>(
  items: Iterable<T>,
  shouldBeGrouped: (item1: T, item2: T) => boolean,
): Iterable<T[]> {
  let currentGroup: T[] | undefined;
  let last: T | undefined;
  for (const item of items) {
    if (last !== undefined && shouldBeGrouped(last, item)) {
      currentGroup!.push(item);
    } else {
      if (currentGroup) {
        yield currentGroup;
      }
      currentGroup = [item];
    }
    last = item;
  }
  if (currentGroup) {
    yield currentGroup;
  }
}
